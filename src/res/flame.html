<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 5px 5px 15px 5px; background-color: #ffffff}
	h1 {margin: 0; font-size: 18px; font-weight: normal; flex-grow: 1; text-align: center}
	header {margin: 0; line-height: 20px; text-align: right; font-size: 11px; color: #666;}
	.title-toolbar-container {
		display: flex;
		align-items: center;
		justify-content: space-between;
		margin-bottom: 2px;
		background-color: #ffffff;
		padding: 1px 2px;
		border: none;
		border-radius: 0;
	}
	.title-section {
		display: flex;
		flex-direction: column;
		align-items: center;
		flex-grow: 1;
	}
	.toolbar-section {
		display: flex;
		align-items: center;
		gap: 2px;
	}
	.left-toolbar {
		display: flex;
		align-items: center;
		gap: 2px;
	}
	.right-section {
		display: flex;
		align-items: center;
	}
	p {position: fixed; bottom: 0; margin: 0; padding: 1px 2px 1px 2px; outline: 1px solid #ffc000; display: none; overflow: hidden; white-space: nowrap; background-color: #ffffe0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 2px 0 2px}
	#status {left: 0}
	#match {right: 0}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: /*height:*/300px}

	#info-tooltip {
		display: none;
		position: fixed;
		width: 404px;
		border: 1px solid #666666;
		background: #ffffe0;
		border-radius: 8px;
		padding: 2px;
		z-index: 1000;
		pointer-events: none;
	}
	.top {
		border-top: .1px solid #000
	}
	.left {
		border-left: .1px solid #000
	}
	.bottom {
		border-bottom: .1px solid #000
	}
	.right {
		border-right: .1px solid #000
	}
	.toolbarIcon {
		width: 24px;
		height: 24px;
		margin: 0 2px;
		display: flex;
		justify-content: center;
		align-items: center;
		cursor: pointer;
	}
	.toolbarSelected {
		background-color: #cccccc;
		outline: 1px solid #999999;
		border-radius: 4px;
	}
	.toolbarIcon:hover {
		background-color: #ffffe0;
		outline: 1px solid #ffc000;
		border-radius: 4px;
	}
	.bordered {
		outline: none;
		border: none;
	}
	.colortip {
		width: 200px;
		box-sizing: border-box;
		padding: 2px;
		margin: 1px 0;
	}
	.colortip-title {
		font-weight: bold;
		padding: 2px;
	}
	.canvas-context-menu {
		position: fixed;
		background-color: white;
		border: 1px solid #ccc;
		box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
		border-radius: 4px;
		padding: 2px 0;
		min-width: 150px;
		z-index: 1000;
		display: none;
	}
	.menu-item {
		padding: 2px 4px;
		cursor: pointer;
	}
	.menu-item:hover {
		background-color: #ffc000;
	}
	.menu-separator {
		height: 1px;
		background-color: #ddd;
		margin: 2px 0;
	}
</style>
</head>
<body style='font: 12px Verdana, sans-serif'>

<div class="title-toolbar-container">
	<div class="left-toolbar">
		<div id="graph-info" class="toolbarIcon"><svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="8" stroke="#004d80" stroke-width="1" fill="none"/><path d="M10 5.5C8.75 5.5 7.75 6.5 7.75 7.75H9C9 7.06 9.56 6.5 10.25 6.5C10.94 6.5 11.5 7.06 11.5 7.75C11.5 8.4 10.95 8.75 10.5 8.95C9.8 9.3 9.25 9.8 9.25 10.75V11H10.75V10.75C10.75 10.38 11.04 10.1 11.43 9.92C12.16 9.58 12.75 9.05 12.75 7.75C12.75 6.5 11.25 5.5 10 5.5Z" fill="#ff8d40" stroke="#ff8d40" stroke-width="0.6" stroke-linecap="round" stroke-linejoin="round"/><circle cx="10" cy="13.5" r="1" fill="#ff8d40"/></svg></div>

		<div id="search" class="toolbarIcon" title="Search by Regex [Ctrl + F]"><svg height="20px" width="20px" viewBox="-39.26 -39.26 471.13 471.13" xml:space="preserve" fill="#000000" stroke="#000000" stroke-width="0.00392609"><path style="fill:#FFFFFF;" d="M273.713,147.774c0,69.495-56.501,125.931-125.931,125.931c-69.495,0-125.931-56.501-125.931-125.931 c0-69.495,56.501-125.931,125.931-125.931C217.212,21.843,273.713,78.344,273.713,147.774z"></path><path style="fill:#40b2ff;" d="M370.747,348.695c0,1.422-1.616,6.271-7.176,12.283c-6.206,6.659-12.477,9.762-14.739,9.762h-0.065 c-19.459-1.616-61.996-43.184-109.576-106.796c0-0.065,0-0.065,0-0.129c9.18-7.24,17.455-15.515,24.63-24.63 c0.065,0,0.065,0,0.129,0C327.564,286.699,369.131,329.301,370.747,348.695z"></path><path style="fill:#ff8d40;" d="M208.679,86.877l-14.481,14.481c-17.131,17.131-46.545,5.042-46.545-19.265V61.6 c-49.002,0-88.372,40.792-86.109,90.246c2.004,43.895,38.141,80.032,82.036,82.036c49.455,2.263,90.246-37.172,90.246-86.109 C233.956,124.049,224.323,102.522,208.679,86.877z"></path><path style="fill:#004d80;" d="M276.105,220.954c12.347-21.527,19.459-46.545,19.459-73.18c0-81.455-66.327-147.717-147.846-147.717 S0,66.32,0,147.904s66.327,147.717,147.717,147.717c26.57,0,51.523-7.111,73.18-19.459 c39.822,53.333,91.863,113.519,126.061,116.364c12.283,0.517,22.885-6.723,32.776-16.743c5.172-5.624,13.77-16.937,12.8-28.768 C389.624,312.881,329.438,260.776,276.105,220.954z M147.717,273.77c-69.495,0-125.931-56.501-125.931-125.931 S78.287,21.908,147.717,21.908s125.931,56.501,125.931,125.931S217.212,273.77,147.717,273.77z M363.572,360.978 c-6.206,6.659-12.412,9.762-14.739,9.762h-0.065c-19.459-1.616-61.996-43.184-109.576-106.796c0-0.065,0-0.065,0-0.129 c9.18-7.24,17.455-15.515,24.63-24.63c0.065,0,0.065,0,0.129,0c63.612,47.58,105.18,90.182,106.796,109.576 C370.747,350.118,369.131,354.966,363.572,360.978z"></path></svg></div>

		<div id="invert" class="toolbarIcon" title="Invert Graph [I]"><svg height="20px" width="20px" viewBox="0 0 20 20"><rect x="0" y="0" style="fill:#ff8d40;" width="20" height="4"></rect><rect x="0" y="5" style="fill:#40b2ff;" width="10" height="4"></rect><rect x="11" y="5" style="fill:#ff8d40;" width="8" height="4"></rect><rect x="0" y="10" style="fill:#40b2ff;" width="8" height="4"></rect><rect x="11" y="10" style="fill:#ff8d40;" width="4" height="4"></rect><rect x="0" y="15" style="fill:#40b2ff;" width="4" height="4"></rect><rect x="5" y="15" style="fill:#ff8d40;" width="2" height="4"></rect></svg></div>

		<div id="info-tooltip">
			<div style="float:left">
				<div class="colortip-title">Frame types:</div>
				<div class="colortip" style="background-color: #e17d00">Kernel</div>
				<div class="colortip" style="background-color: #e15a5a">Native</div>
				<div class="colortip" style="background-color: #c8c83c">C++ (VM)</div>
				<div class="colortip" style="background-color: #50e150">Java compiled (C2/JVMCI)</div>
				<div class="colortip" style="background-color: #cce880">Java C1 compiled</div>
				<div class="colortip" style="background-color: #50cccc">Java inlined</div>
				<div class="colortip" style="background-color: #b2e1b2">Interpreted</div>
			</div>
			<div style="float:left; margin-left: 2px">
				<div class="colortip-title">Special colors:</div>
				<div class="colortip" style="background-color: #ee00ee">Matches regexp</div>
				<div class="colortip-title">Allocation mode:</div>
				<div class="colortip" style="background-color: #e17d00">Allocation outside TLAB</div>
				<div class="colortip" style="background-color: #50cccc">Allocated object</div>
				<div class="colortip-title">Lock mode:</div>
				<div class="colortip" style="background-color: #50cccc">Locked object</div>
			</div>
			<div style="float:left; margin-top: 2px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 1px; box-sizing: border-box;">
				Click frame - Zoom in frame<br>
				Alt + click frame - Remove frame<br>
				0 - Reset zoom<br>
				<br>
				Ctrl + F - Search<br>
				N - Focus on next match<br>
				Shift + N - Focus on previous match<br>
				Esc - Cancel search<br>
				<br>
				I - invert graph<br>
			</div>
		</div>
	</div>

	<div class="title-section">
		<h1>/*title:*/</h1>
	</div>

	<div class="right-section">
		<header>Produced by <a href='https://github.com/async-profiler/async-profiler'>async-profiler</a></header>
	</div>
</div>

<div class='bordered' style="display: flex; flex-direction: column;">
	<div class="canvas-context-menu" id="ctxMenu">
		<div id="ctxHighlightFrameType" class="menu-item">Highlight frame type</div>
		<div id="ctxResetHighlight" class="menu-item">Reset frame type highlight</div>
		<div class="menu-separator"></div>
		<div id="ctxHideFrame" class="menu-item">Hide frame</div>
		<div class="menu-separator"></div>
		<div id="ctxResetZoom" class="menu-item">Reset zoom</div>
	</div>
	<canvas id='canvas'></canvas>
	<div id='hl'><span></span></div>
	<p id='status'></p>
	<p id='match'>Matched: <span id='matchval'></span> <span id='reset' title='Clear'>&#x274c;</span></p>
</div>
<script>
	// Copyright The async-profiler authors
	// SPDX-License-Identifier: Apache-2.0
	'use strict';
	let origRoot, root, px, pattern;
	let level0 = 0, left0 = 0, width0 = 0;
	let nav = [], navIndex, matchval;
	let inverted = /*inverted:*/false;
	const levels = Array(/*depth:*/0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	const c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');
	const ctxMenu = document.getElementById('ctxMenu');
	const ctxHighlightFrameType = document.getElementById('ctxHighlightFrameType');
	const ctxResetHighlight = document.getElementById('ctxResetHighlight');
	const ctxHideFrame = document.getElementById('ctxHideFrame');
	const ctxResetZoom = document.getElementById('ctxResetZoom');
	const infoTooltip = document.getElementById('info-tooltip');
	const graphInfo = document.getElementById('graph-info');
	const btnInvert = document.getElementById('invert');

	const canvasWidth = canvas.offsetWidth;
	const canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

	function positionTooltip(e) {
		const tooltipWidth = 404;
		const tooltipHeight = infoTooltip.offsetHeight || 200;
		const margin = 15;

		let left = e.pageX + margin;
		let top = e.pageY + margin;

		if (left + tooltipWidth > window.innerWidth) {
			left = e.pageX - tooltipWidth - margin;
		}

		if (top + tooltipHeight > window.innerHeight + window.scrollY) {
			top = e.pageY - tooltipHeight - margin;
		}

		infoTooltip.style.left = left + 'px';
		infoTooltip.style.top = top + 'px';
	}

	graphInfo.addEventListener('mouseenter', function(e) {
		infoTooltip.style.display = 'block';
		positionTooltip(e);
	});

	graphInfo.addEventListener('mousemove', function(e) {
		positionTooltip(e);
	});

	graphInfo.addEventListener('mouseleave', function() {
		infoTooltip.style.display = 'none';
	});

	let focusOnType = null;
	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30, 0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(f) {
		if (focusOnType === null) {
			return f.color;
		}

		if (focusOnType === f.type) {
			// emphasis color
			return '#ff2291';
		}

		const color = Number.parseInt(f.color.substring(1), 16);

		// deemphasized color
		const r = (color >> 16) & 0xFF;
		const g = (color >> 8) & 0xFF;
		const b = color & 0xFF;
		const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
		const amount = 0.65;
		return '#' + ((Math.round(r * (1 - amount) + gray * amount) << 16)
			| (Math.round(g * (1 - amount) + gray * amount) << 8)
			| (Math.round(b * (1 - amount) + gray * amount))).toString(16);
	}

	function getTypeColor(type) {
		const v = Math.random();
		const p = palette[type];
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(key, level, left, width, inln, c1, int) {
		levels[level0 = level].push({level, left: left0 += left, width: width0 = width || width0,
			color: getTypeColor(key & 7), title: cpool[key >>> 3],
			type: key & 7,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function u(key, width, inln, c1, int) {
		f(key, level0 + 1, 0, width, inln, c1, int)
	}

	function n(key, width, inln, c1, int) {
		f(key, level0, width0, width, inln, c1, int)
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

	function removeStack(left, width) {
		for (let h = 0; h < levels.length; h++) {
			const frames = levels[h], newFrames = [];
			for (let i = 0; i < frames.length; i++) {
				const f = frames[i];
				if (f.left >= left + width) {
					f.left -= width;
				} else if (f.left + f.width > left) {
					if ((f.width -= width) <= 0 && h) continue;
				}
				newFrames.push(f);
			}
			levels[h] = newFrames;
		}
	}

	function search(r, resetZoom) {
		if (r === true && (r = prompt('Enter regexp to search:', '')) === null) {
			return;
		}

		pattern = r ? RegExp(r) : undefined;

		if (resetZoom) {
			root = origRoot;
		}

		const matched = render(root, nav = []);
		if (!origRoot) {
			origRoot = root;
		}

		navIndex = -1;
		document.getElementById('matchval').textContent = matchval = pct(matched, root.width) + '%';
		document.getElementById('match').style.display = r ? 'inline-block' : 'none';
	}

	function render(newRoot, nav) {
		if (root) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;
		const marked = [];

		function mark(f) {
			return marked[f.left] || (marked[f.left] = f);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					const m = marked[x];
					if (nav) nav.push(m);
					total += m.width;
					left = +x + m.width;
				}
			});
			return total;
		}

		function drawFrame(f, y) {
			if (f.left < x1 && f.left + f.width > x0) {
				c.fillStyle = pattern && f.title.match(pattern) && mark(f) ? '#ee00ee' : getColor(f);
				c.fillRect((f.left - x0) * px, y, f.width * px, 15);

				if (f.width * px >= 21) {
					const chars = Math.floor(f.width * px / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, f.width * px - 6);
				}

				if (f.level < root.level) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, f.width * px, 15);
				}
			}
		}

		for (let h = 0; h < levels.length; h++) {
			const y = inverted ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y);
			}
		}

		return totalMarked();
	}

	function unpack(cpool) {
		for (let i = 1; i < cpool.length; i++) {
			cpool[i] = cpool[i - 1].substring(0, cpool[i].charCodeAt(0) - 32) + cpool[i].substring(1);
		}
	}

	function positionContextMenu(e) {
		const menuWidth = 150;
		const menuHeight = ctxMenu.offsetHeight || 100;
		const margin = 5;
		const viewportWidth = window.innerWidth;
		const viewportHeight = window.innerHeight;

		let left = e.clientX + margin;
		let top = e.clientY + margin;

		if (left + menuWidth > viewportWidth) {
			left = e.clientX - menuWidth - margin;
		}

		if (top + menuHeight > viewportHeight) {
			top = e.clientY - menuHeight - margin;
		}

		left = Math.max(margin, Math.min(left, viewportWidth - menuWidth - margin));
		top = Math.max(margin, Math.min(top, viewportHeight - menuHeight - margin));

		ctxMenu.style.left = left + 'px';
		ctxMenu.style.top = top + 'px';
	}

	canvas.onmousemove = function() {
		const h = Math.floor((inverted ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				if (f !== root) getSelection().removeAllRanges();
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((inverted ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				canvas.title = f.title + '\n(' + samples(f.width) + f.details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (event.altKey && h > root.level) {
						removeStack(f.left, f.width);
						root.width > f.width ? render(root) : render();
					} else if (f !== root) {
						render(f);
					}
					canvas.onmousemove();
				};
				canvas.addEventListener('contextmenu', function(e) {
					if (e.shiftKey) {
						return true;
					}
					e.preventDefault();
					e.stopPropagation();

					ctxMenu.style.display = 'block';
					positionContextMenu(e);

					ctxHighlightFrameType.onclick = function(e) {
						e.stopPropagation();
						focusOnType = f.type;
						render(root);
						ctxMenu.style.display = 'none';
					}
					ctxHideFrame.onclick = function(e) {
						e.stopPropagation();
						if (h >= root.level) {
							removeStack(f.left, f.width);
							root.width > f.width ? render(root) : render();
						}
						ctxMenu.style.display = 'none';
					}
					ctxResetZoom.onclick = function(e) {
						e.stopPropagation();
						search(false, true);
						ctxMenu.style.display = 'none';
					}
				});
				status.textContent = 'Function: ' + canvas.title;
				status.style.display = 'inline-block';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = null;
	}

	canvas.ondblclick = function() {
		getSelection().selectAllChildren(hl);
	}

	document.getElementById('search').onclick = function() {
		search(true);
	}

	document.getElementById('reset').onclick = function() {
		search(false);
	}

	btnInvert.onclick = function(e) {
		invertMode();
	}

	document.onclick = function () {
		ctxMenu.style.display = 'none';
	}

	ctxResetHighlight.onclick = function(e) {
		e.stopPropagation();
		focusOnType = null;
		render(root);
		ctxMenu.style.display = 'none';
	}

	window.onkeydown = function(event) {
		if (event.key === 'Escape') {
			search(false);
		} else if(event.ctrlKey || event.metaKey) {
			switch(event.key) {
				case 'f':
					event.preventDefault();
					search(true);
					break;
			}
		} else {
			switch(event.key) {
				case 'n':
					if (nav.length > 0) {
						navIndex = (navIndex + (event.shiftKey ? nav.length - 1 : 1)) % nav.length;
						render(nav[navIndex]);
						document.getElementById('matchval').textContent = matchval + ' (' + (navIndex + 1) + ' of ' + nav.length + ')';
						window.scroll(0, inverted ? root.level * 16 : canvasHeight - (root.level + 1) * 16);
						canvas.onmousemove();
					}
					break;
				case 'i':
					event.preventDefault();
					invertMode();
					break;
				case '0':
					event.preventDefault();
					search(false, true);
					break;
			}
		}
	}

	function invertMode() {
		inverted = !inverted;
		btnInvert.style.rotate = inverted ? '180deg' : '0deg';

		render();
	}

const cpool = [
/*cpool:*/
];
unpack(cpool);

/*frames:*/
search(/*highlight:*/);
</script></body></html>
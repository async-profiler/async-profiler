// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: opentelemetry/proto/profiles/v1development/profiles.proto

package io.opentelemetry.proto.profiles.v1development;

/**
 * <pre>
 * Specifies the method of aggregating metric values, either DELTA (change since last report)
 * or CUMULATIVE (total since a fixed start time).
 * </pre>
 *
 * Protobuf enum {@code opentelemetry.proto.profiles.v1development.AggregationTemporality}
 */
public enum AggregationTemporality
    implements com.google.protobuf.ProtocolMessageEnum {
  /**
   * <pre>
   * UNSPECIFIED is the default AggregationTemporality, it MUST not be used. 
   * </pre>
   *
   * <code>AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;</code>
   */
  AGGREGATION_TEMPORALITY_UNSPECIFIED(0),
  /**
   * <pre>
   ** DELTA is an AggregationTemporality for a profiler which reports
   *changes since last report time. Successive metrics contain aggregation of
   *values from continuous and non-overlapping intervals.
   *The values for a DELTA metric are based only on the time interval
   *associated with one measurement cycle. There is no dependency on
   *previous measurements like is the case for CUMULATIVE metrics.
   *For example, consider a system measuring the number of requests that
   *it receives and reports the sum of these requests every second as a
   *DELTA metric:
   *1. The system starts receiving at time=t_0.
   *2. A request is received, the system measures 1 request.
   *3. A request is received, the system measures 1 request.
   *4. A request is received, the system measures 1 request.
   *5. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0 to
   *t_0+1 with a value of 3.
   *6. A request is received, the system measures 1 request.
   *7. A request is received, the system measures 1 request.
   *8. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0+1 to
   *t_0+2 with a value of 2. 
   * </pre>
   *
   * <code>AGGREGATION_TEMPORALITY_DELTA = 1;</code>
   */
  AGGREGATION_TEMPORALITY_DELTA(1),
  /**
   * <pre>
   ** CUMULATIVE is an AggregationTemporality for a profiler which
   *reports changes since a fixed start time. This means that current values
   *of a CUMULATIVE metric depend on all previous measurements since the
   *start time. Because of this, the sender is required to retain this state
   *in some form. If this state is lost or invalidated, the CUMULATIVE metric
   *values MUST be reset and a new fixed start time following the last
   *reported measurement time sent MUST be used.
   *For example, consider a system measuring the number of requests that
   *it receives and reports the sum of these requests every second as a
   *CUMULATIVE metric:
   *1. The system starts receiving at time=t_0.
   *2. A request is received, the system measures 1 request.
   *3. A request is received, the system measures 1 request.
   *4. A request is received, the system measures 1 request.
   *5. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0 to
   *t_0+1 with a value of 3.
   *6. A request is received, the system measures 1 request.
   *7. A request is received, the system measures 1 request.
   *8. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0 to
   *t_0+2 with a value of 5.
   *9. The system experiences a fault and loses state.
   *10. The system recovers and resumes receiving at time=t_1.
   *11. A request is received, the system measures 1 request.
   *12. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_1 to
   *t_1+1 with a value of 1.
   *Note: Even though, when reporting changes since last report time, using
   *CUMULATIVE is valid, it is not recommended. 
   * </pre>
   *
   * <code>AGGREGATION_TEMPORALITY_CUMULATIVE = 2;</code>
   */
  AGGREGATION_TEMPORALITY_CUMULATIVE(2),
  UNRECOGNIZED(-1),
  ;

  /**
   * <pre>
   * UNSPECIFIED is the default AggregationTemporality, it MUST not be used. 
   * </pre>
   *
   * <code>AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;</code>
   */
  public static final int AGGREGATION_TEMPORALITY_UNSPECIFIED_VALUE = 0;
  /**
   * <pre>
   ** DELTA is an AggregationTemporality for a profiler which reports
   *changes since last report time. Successive metrics contain aggregation of
   *values from continuous and non-overlapping intervals.
   *The values for a DELTA metric are based only on the time interval
   *associated with one measurement cycle. There is no dependency on
   *previous measurements like is the case for CUMULATIVE metrics.
   *For example, consider a system measuring the number of requests that
   *it receives and reports the sum of these requests every second as a
   *DELTA metric:
   *1. The system starts receiving at time=t_0.
   *2. A request is received, the system measures 1 request.
   *3. A request is received, the system measures 1 request.
   *4. A request is received, the system measures 1 request.
   *5. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0 to
   *t_0+1 with a value of 3.
   *6. A request is received, the system measures 1 request.
   *7. A request is received, the system measures 1 request.
   *8. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0+1 to
   *t_0+2 with a value of 2. 
   * </pre>
   *
   * <code>AGGREGATION_TEMPORALITY_DELTA = 1;</code>
   */
  public static final int AGGREGATION_TEMPORALITY_DELTA_VALUE = 1;
  /**
   * <pre>
   ** CUMULATIVE is an AggregationTemporality for a profiler which
   *reports changes since a fixed start time. This means that current values
   *of a CUMULATIVE metric depend on all previous measurements since the
   *start time. Because of this, the sender is required to retain this state
   *in some form. If this state is lost or invalidated, the CUMULATIVE metric
   *values MUST be reset and a new fixed start time following the last
   *reported measurement time sent MUST be used.
   *For example, consider a system measuring the number of requests that
   *it receives and reports the sum of these requests every second as a
   *CUMULATIVE metric:
   *1. The system starts receiving at time=t_0.
   *2. A request is received, the system measures 1 request.
   *3. A request is received, the system measures 1 request.
   *4. A request is received, the system measures 1 request.
   *5. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0 to
   *t_0+1 with a value of 3.
   *6. A request is received, the system measures 1 request.
   *7. A request is received, the system measures 1 request.
   *8. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_0 to
   *t_0+2 with a value of 5.
   *9. The system experiences a fault and loses state.
   *10. The system recovers and resumes receiving at time=t_1.
   *11. A request is received, the system measures 1 request.
   *12. The 1 second collection cycle ends. A metric is exported for the
   *number of requests received over the interval of time t_1 to
   *t_1+1 with a value of 1.
   *Note: Even though, when reporting changes since last report time, using
   *CUMULATIVE is valid, it is not recommended. 
   * </pre>
   *
   * <code>AGGREGATION_TEMPORALITY_CUMULATIVE = 2;</code>
   */
  public static final int AGGREGATION_TEMPORALITY_CUMULATIVE_VALUE = 2;


  public final int getNumber() {
    if (this == UNRECOGNIZED) {
      throw new java.lang.IllegalArgumentException(
          "Can't get the number of an unknown enum value.");
    }
    return value;
  }

  /**
   * @param value The numeric wire value of the corresponding enum entry.
   * @return The enum associated with the given numeric wire value.
   * @deprecated Use {@link #forNumber(int)} instead.
   */
  @java.lang.Deprecated
  public static AggregationTemporality valueOf(int value) {
    return forNumber(value);
  }

  /**
   * @param value The numeric wire value of the corresponding enum entry.
   * @return The enum associated with the given numeric wire value.
   */
  public static AggregationTemporality forNumber(int value) {
    switch (value) {
      case 0: return AGGREGATION_TEMPORALITY_UNSPECIFIED;
      case 1: return AGGREGATION_TEMPORALITY_DELTA;
      case 2: return AGGREGATION_TEMPORALITY_CUMULATIVE;
      default: return null;
    }
  }

  public static com.google.protobuf.Internal.EnumLiteMap<AggregationTemporality>
      internalGetValueMap() {
    return internalValueMap;
  }
  private static final com.google.protobuf.Internal.EnumLiteMap<
      AggregationTemporality> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AggregationTemporality>() {
          public AggregationTemporality findValueByNumber(int number) {
            return AggregationTemporality.forNumber(number);
          }
        };

  public final com.google.protobuf.Descriptors.EnumValueDescriptor
      getValueDescriptor() {
    if (this == UNRECOGNIZED) {
      throw new java.lang.IllegalStateException(
          "Can't get the descriptor of an unrecognized enum value.");
    }
    return getDescriptor().getValues().get(ordinal());
  }
  public final com.google.protobuf.Descriptors.EnumDescriptor
      getDescriptorForType() {
    return getDescriptor();
  }
  public static final com.google.protobuf.Descriptors.EnumDescriptor
      getDescriptor() {
    return io.opentelemetry.proto.profiles.v1development.ProfilesProto.getDescriptor().getEnumTypes().get(0);
  }

  private static final AggregationTemporality[] VALUES = values();

  public static AggregationTemporality valueOf(
      com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
      throw new java.lang.IllegalArgumentException(
        "EnumValueDescriptor is not for this type.");
    }
    if (desc.getIndex() == -1) {
      return UNRECOGNIZED;
    }
    return VALUES[desc.getIndex()];
  }

  private final int value;

  private AggregationTemporality(int value) {
    this.value = value;
  }

  // @@protoc_insertion_point(enum_scope:opentelemetry.proto.profiles.v1development.AggregationTemporality)
}


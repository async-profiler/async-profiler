// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: opentelemetry/proto/profiles/v1development/profiles.proto

package io.opentelemetry.proto.profiles.v1development;

/**
 * <pre>
 * Represents a complete profile, including sample types, samples,
 * mappings to binaries, locations, functions, string table, and additional metadata.
 * It modifies and annotates pprof Profile with OpenTelemetry specific fields.
 * Note that whilst fields in this message retain the name and field id from pprof in most cases
 * for ease of understanding data migration, it is not intended that pprof:Profile and
 * OpenTelemetry:Profile encoding be wire compatible.
 * </pre>
 *
 * Protobuf type {@code opentelemetry.proto.profiles.v1development.Profile}
 */
public final class Profile extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:opentelemetry.proto.profiles.v1development.Profile)
    ProfileOrBuilder {
private static final long serialVersionUID = 0L;
  // Use Profile.newBuilder() to construct.
  private Profile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private Profile() {
    sampleType_ = java.util.Collections.emptyList();
    sample_ = java.util.Collections.emptyList();
    locationIndices_ = emptyIntList();
    commentStrindices_ = emptyIntList();
    profileId_ = com.google.protobuf.ByteString.EMPTY;
    originalPayloadFormat_ = "";
    originalPayload_ = com.google.protobuf.ByteString.EMPTY;
    attributeIndices_ = emptyIntList();
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new Profile();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private Profile(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {
            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
              sampleType_ = new java.util.ArrayList<io.opentelemetry.proto.profiles.v1development.ValueType>();
              mutable_bitField0_ |= 0x00000001;
            }
            sampleType_.add(
                input.readMessage(io.opentelemetry.proto.profiles.v1development.ValueType.parser(), extensionRegistry));
            break;
          }
          case 18: {
            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
              sample_ = new java.util.ArrayList<io.opentelemetry.proto.profiles.v1development.Sample>();
              mutable_bitField0_ |= 0x00000002;
            }
            sample_.add(
                input.readMessage(io.opentelemetry.proto.profiles.v1development.Sample.parser(), extensionRegistry));
            break;
          }
          case 24: {
            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
              locationIndices_ = newIntList();
              mutable_bitField0_ |= 0x00000004;
            }
            locationIndices_.addInt(input.readInt32());
            break;
          }
          case 26: {
            int length = input.readRawVarint32();
            int limit = input.pushLimit(length);
            if (!((mutable_bitField0_ & 0x00000004) != 0) && input.getBytesUntilLimit() > 0) {
              locationIndices_ = newIntList();
              mutable_bitField0_ |= 0x00000004;
            }
            while (input.getBytesUntilLimit() > 0) {
              locationIndices_.addInt(input.readInt32());
            }
            input.popLimit(limit);
            break;
          }
          case 32: {

            timeNanos_ = input.readInt64();
            break;
          }
          case 40: {

            durationNanos_ = input.readInt64();
            break;
          }
          case 50: {
            io.opentelemetry.proto.profiles.v1development.ValueType.Builder subBuilder = null;
            if (periodType_ != null) {
              subBuilder = periodType_.toBuilder();
            }
            periodType_ = input.readMessage(io.opentelemetry.proto.profiles.v1development.ValueType.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(periodType_);
              periodType_ = subBuilder.buildPartial();
            }

            break;
          }
          case 56: {

            period_ = input.readInt64();
            break;
          }
          case 64: {
            if (!((mutable_bitField0_ & 0x00000008) != 0)) {
              commentStrindices_ = newIntList();
              mutable_bitField0_ |= 0x00000008;
            }
            commentStrindices_.addInt(input.readInt32());
            break;
          }
          case 66: {
            int length = input.readRawVarint32();
            int limit = input.pushLimit(length);
            if (!((mutable_bitField0_ & 0x00000008) != 0) && input.getBytesUntilLimit() > 0) {
              commentStrindices_ = newIntList();
              mutable_bitField0_ |= 0x00000008;
            }
            while (input.getBytesUntilLimit() > 0) {
              commentStrindices_.addInt(input.readInt32());
            }
            input.popLimit(limit);
            break;
          }
          case 72: {

            defaultSampleTypeIndex_ = input.readInt32();
            break;
          }
          case 82: {

            profileId_ = input.readBytes();
            break;
          }
          case 88: {

            droppedAttributesCount_ = input.readUInt32();
            break;
          }
          case 98: {
            java.lang.String s = input.readStringRequireUtf8();

            originalPayloadFormat_ = s;
            break;
          }
          case 106: {

            originalPayload_ = input.readBytes();
            break;
          }
          case 112: {
            if (!((mutable_bitField0_ & 0x00000010) != 0)) {
              attributeIndices_ = newIntList();
              mutable_bitField0_ |= 0x00000010;
            }
            attributeIndices_.addInt(input.readInt32());
            break;
          }
          case 114: {
            int length = input.readRawVarint32();
            int limit = input.pushLimit(length);
            if (!((mutable_bitField0_ & 0x00000010) != 0) && input.getBytesUntilLimit() > 0) {
              attributeIndices_ = newIntList();
              mutable_bitField0_ |= 0x00000010;
            }
            while (input.getBytesUntilLimit() > 0) {
              attributeIndices_.addInt(input.readInt32());
            }
            input.popLimit(limit);
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (com.google.protobuf.UninitializedMessageException e) {
      throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000001) != 0)) {
        sampleType_ = java.util.Collections.unmodifiableList(sampleType_);
      }
      if (((mutable_bitField0_ & 0x00000002) != 0)) {
        sample_ = java.util.Collections.unmodifiableList(sample_);
      }
      if (((mutable_bitField0_ & 0x00000004) != 0)) {
        locationIndices_.makeImmutable(); // C
      }
      if (((mutable_bitField0_ & 0x00000008) != 0)) {
        commentStrindices_.makeImmutable(); // C
      }
      if (((mutable_bitField0_ & 0x00000010) != 0)) {
        attributeIndices_.makeImmutable(); // C
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.opentelemetry.proto.profiles.v1development.ProfilesProto.internal_static_opentelemetry_proto_profiles_v1development_Profile_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.opentelemetry.proto.profiles.v1development.ProfilesProto.internal_static_opentelemetry_proto_profiles_v1development_Profile_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.opentelemetry.proto.profiles.v1development.Profile.class, io.opentelemetry.proto.profiles.v1development.Profile.Builder.class);
  }

  public static final int SAMPLE_TYPE_FIELD_NUMBER = 1;
  private java.util.List<io.opentelemetry.proto.profiles.v1development.ValueType> sampleType_;
  /**
   * <pre>
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
   */
  @java.lang.Override
  public java.util.List<io.opentelemetry.proto.profiles.v1development.ValueType> getSampleTypeList() {
    return sampleType_;
  }
  /**
   * <pre>
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder> 
      getSampleTypeOrBuilderList() {
    return sampleType_;
  }
  /**
   * <pre>
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
   */
  @java.lang.Override
  public int getSampleTypeCount() {
    return sampleType_.size();
  }
  /**
   * <pre>
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
   */
  @java.lang.Override
  public io.opentelemetry.proto.profiles.v1development.ValueType getSampleType(int index) {
    return sampleType_.get(index);
  }
  /**
   * <pre>
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
   */
  @java.lang.Override
  public io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder getSampleTypeOrBuilder(
      int index) {
    return sampleType_.get(index);
  }

  public static final int SAMPLE_FIELD_NUMBER = 2;
  private java.util.List<io.opentelemetry.proto.profiles.v1development.Sample> sample_;
  /**
   * <pre>
   * The set of samples recorded in this profile.
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
   */
  @java.lang.Override
  public java.util.List<io.opentelemetry.proto.profiles.v1development.Sample> getSampleList() {
    return sample_;
  }
  /**
   * <pre>
   * The set of samples recorded in this profile.
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.opentelemetry.proto.profiles.v1development.SampleOrBuilder> 
      getSampleOrBuilderList() {
    return sample_;
  }
  /**
   * <pre>
   * The set of samples recorded in this profile.
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
   */
  @java.lang.Override
  public int getSampleCount() {
    return sample_.size();
  }
  /**
   * <pre>
   * The set of samples recorded in this profile.
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
   */
  @java.lang.Override
  public io.opentelemetry.proto.profiles.v1development.Sample getSample(int index) {
    return sample_.get(index);
  }
  /**
   * <pre>
   * The set of samples recorded in this profile.
   * </pre>
   *
   * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
   */
  @java.lang.Override
  public io.opentelemetry.proto.profiles.v1development.SampleOrBuilder getSampleOrBuilder(
      int index) {
    return sample_.get(index);
  }

  public static final int LOCATION_INDICES_FIELD_NUMBER = 3;
  private com.google.protobuf.Internal.IntList locationIndices_;
  /**
   * <pre>
   * References to locations in ProfilesDictionary.location_table.
   * </pre>
   *
   * <code>repeated int32 location_indices = 3;</code>
   * @return A list containing the locationIndices.
   */
  @java.lang.Override
  public java.util.List<java.lang.Integer>
      getLocationIndicesList() {
    return locationIndices_;
  }
  /**
   * <pre>
   * References to locations in ProfilesDictionary.location_table.
   * </pre>
   *
   * <code>repeated int32 location_indices = 3;</code>
   * @return The count of locationIndices.
   */
  public int getLocationIndicesCount() {
    return locationIndices_.size();
  }
  /**
   * <pre>
   * References to locations in ProfilesDictionary.location_table.
   * </pre>
   *
   * <code>repeated int32 location_indices = 3;</code>
   * @param index The index of the element to return.
   * @return The locationIndices at the given index.
   */
  public int getLocationIndices(int index) {
    return locationIndices_.getInt(index);
  }
  private int locationIndicesMemoizedSerializedSize = -1;

  public static final int TIME_NANOS_FIELD_NUMBER = 4;
  private long timeNanos_;
  /**
   * <pre>
   * Time of collection (UTC) represented as nanoseconds past the epoch.
   * </pre>
   *
   * <code>int64 time_nanos = 4;</code>
   * @return The timeNanos.
   */
  @java.lang.Override
  public long getTimeNanos() {
    return timeNanos_;
  }

  public static final int DURATION_NANOS_FIELD_NUMBER = 5;
  private long durationNanos_;
  /**
   * <pre>
   * Duration of the profile, if a duration makes sense.
   * </pre>
   *
   * <code>int64 duration_nanos = 5;</code>
   * @return The durationNanos.
   */
  @java.lang.Override
  public long getDurationNanos() {
    return durationNanos_;
  }

  public static final int PERIOD_TYPE_FIELD_NUMBER = 6;
  private io.opentelemetry.proto.profiles.v1development.ValueType periodType_;
  /**
   * <pre>
   * The kind of events between sampled occurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   * </pre>
   *
   * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
   * @return Whether the periodType field is set.
   */
  @java.lang.Override
  public boolean hasPeriodType() {
    return periodType_ != null;
  }
  /**
   * <pre>
   * The kind of events between sampled occurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   * </pre>
   *
   * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
   * @return The periodType.
   */
  @java.lang.Override
  public io.opentelemetry.proto.profiles.v1development.ValueType getPeriodType() {
    return periodType_ == null ? io.opentelemetry.proto.profiles.v1development.ValueType.getDefaultInstance() : periodType_;
  }
  /**
   * <pre>
   * The kind of events between sampled occurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   * </pre>
   *
   * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
   */
  @java.lang.Override
  public io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder getPeriodTypeOrBuilder() {
    return getPeriodType();
  }

  public static final int PERIOD_FIELD_NUMBER = 7;
  private long period_;
  /**
   * <pre>
   * The number of events between sampled occurrences.
   * </pre>
   *
   * <code>int64 period = 7;</code>
   * @return The period.
   */
  @java.lang.Override
  public long getPeriod() {
    return period_;
  }

  public static final int COMMENT_STRINDICES_FIELD_NUMBER = 8;
  private com.google.protobuf.Internal.IntList commentStrindices_;
  /**
   * <pre>
   * Free-form text associated with the profile. The text is displayed as is
   * to the user by the tools that read profiles (e.g. by pprof). This field
   * should not be used to store any machine-readable information, it is only
   * for human-friendly content. The profile must stay functional if this field
   * is cleaned.
   * </pre>
   *
   * <code>repeated int32 comment_strindices = 8;</code>
   * @return A list containing the commentStrindices.
   */
  @java.lang.Override
  public java.util.List<java.lang.Integer>
      getCommentStrindicesList() {
    return commentStrindices_;
  }
  /**
   * <pre>
   * Free-form text associated with the profile. The text is displayed as is
   * to the user by the tools that read profiles (e.g. by pprof). This field
   * should not be used to store any machine-readable information, it is only
   * for human-friendly content. The profile must stay functional if this field
   * is cleaned.
   * </pre>
   *
   * <code>repeated int32 comment_strindices = 8;</code>
   * @return The count of commentStrindices.
   */
  public int getCommentStrindicesCount() {
    return commentStrindices_.size();
  }
  /**
   * <pre>
   * Free-form text associated with the profile. The text is displayed as is
   * to the user by the tools that read profiles (e.g. by pprof). This field
   * should not be used to store any machine-readable information, it is only
   * for human-friendly content. The profile must stay functional if this field
   * is cleaned.
   * </pre>
   *
   * <code>repeated int32 comment_strindices = 8;</code>
   * @param index The index of the element to return.
   * @return The commentStrindices at the given index.
   */
  public int getCommentStrindices(int index) {
    return commentStrindices_.getInt(index);
  }
  private int commentStrindicesMemoizedSerializedSize = -1;

  public static final int DEFAULT_SAMPLE_TYPE_INDEX_FIELD_NUMBER = 9;
  private int defaultSampleTypeIndex_;
  /**
   * <pre>
   * Index into the sample_type array to the default sample type.
   * </pre>
   *
   * <code>int32 default_sample_type_index = 9;</code>
   * @return The defaultSampleTypeIndex.
   */
  @java.lang.Override
  public int getDefaultSampleTypeIndex() {
    return defaultSampleTypeIndex_;
  }

  public static final int PROFILE_ID_FIELD_NUMBER = 10;
  private com.google.protobuf.ByteString profileId_;
  /**
   * <pre>
   * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
   * all zeroes is considered invalid.
   * This field is required.
   * </pre>
   *
   * <code>bytes profile_id = 10;</code>
   * @return The profileId.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getProfileId() {
    return profileId_;
  }

  public static final int DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER = 11;
  private int droppedAttributesCount_;
  /**
   * <pre>
   * dropped_attributes_count is the number of attributes that were discarded. Attributes
   * can be discarded because their keys are too long or because there are too many
   * attributes. If this value is 0, then no attributes were dropped.
   * </pre>
   *
   * <code>uint32 dropped_attributes_count = 11;</code>
   * @return The droppedAttributesCount.
   */
  @java.lang.Override
  public int getDroppedAttributesCount() {
    return droppedAttributesCount_;
  }

  public static final int ORIGINAL_PAYLOAD_FORMAT_FIELD_NUMBER = 12;
  private volatile java.lang.Object originalPayloadFormat_;
  /**
   * <pre>
   * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
   * </pre>
   *
   * <code>string original_payload_format = 12;</code>
   * @return The originalPayloadFormat.
   */
  @java.lang.Override
  public java.lang.String getOriginalPayloadFormat() {
    java.lang.Object ref = originalPayloadFormat_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      originalPayloadFormat_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
   * </pre>
   *
   * <code>string original_payload_format = 12;</code>
   * @return The bytes for originalPayloadFormat.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getOriginalPayloadFormatBytes() {
    java.lang.Object ref = originalPayloadFormat_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      originalPayloadFormat_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ORIGINAL_PAYLOAD_FIELD_NUMBER = 13;
  private com.google.protobuf.ByteString originalPayload_;
  /**
   * <pre>
   * Original payload can be stored in this field. This can be useful for users who want to get the original payload.
   * Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
   * Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
   * If the original payload is in pprof format, it SHOULD not be included in this field.
   * The field is optional, however if it is present then equivalent converted data should be populated in other fields
   * of this message as far as is practicable.
   * </pre>
   *
   * <code>bytes original_payload = 13;</code>
   * @return The originalPayload.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getOriginalPayload() {
    return originalPayload_;
  }

  public static final int ATTRIBUTE_INDICES_FIELD_NUMBER = 14;
  private com.google.protobuf.Internal.IntList attributeIndices_;
  /**
   * <pre>
   * References to attributes in attribute_table. [optional]
   * It is a collection of key/value pairs. Note, global attributes
   * like server name can be set using the resource API. Examples of attributes:
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "/http/server_latency": 300
   *     "abc.com/myattribute": true
   *     "abc.com/score": 10.239
   * The OpenTelemetry API specification further restricts the allowed value types:
   * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * </pre>
   *
   * <code>repeated int32 attribute_indices = 14;</code>
   * @return A list containing the attributeIndices.
   */
  @java.lang.Override
  public java.util.List<java.lang.Integer>
      getAttributeIndicesList() {
    return attributeIndices_;
  }
  /**
   * <pre>
   * References to attributes in attribute_table. [optional]
   * It is a collection of key/value pairs. Note, global attributes
   * like server name can be set using the resource API. Examples of attributes:
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "/http/server_latency": 300
   *     "abc.com/myattribute": true
   *     "abc.com/score": 10.239
   * The OpenTelemetry API specification further restricts the allowed value types:
   * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * </pre>
   *
   * <code>repeated int32 attribute_indices = 14;</code>
   * @return The count of attributeIndices.
   */
  public int getAttributeIndicesCount() {
    return attributeIndices_.size();
  }
  /**
   * <pre>
   * References to attributes in attribute_table. [optional]
   * It is a collection of key/value pairs. Note, global attributes
   * like server name can be set using the resource API. Examples of attributes:
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "/http/server_latency": 300
   *     "abc.com/myattribute": true
   *     "abc.com/score": 10.239
   * The OpenTelemetry API specification further restricts the allowed value types:
   * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * </pre>
   *
   * <code>repeated int32 attribute_indices = 14;</code>
   * @param index The index of the element to return.
   * @return The attributeIndices at the given index.
   */
  public int getAttributeIndices(int index) {
    return attributeIndices_.getInt(index);
  }
  private int attributeIndicesMemoizedSerializedSize = -1;

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    getSerializedSize();
    for (int i = 0; i < sampleType_.size(); i++) {
      output.writeMessage(1, sampleType_.get(i));
    }
    for (int i = 0; i < sample_.size(); i++) {
      output.writeMessage(2, sample_.get(i));
    }
    if (getLocationIndicesList().size() > 0) {
      output.writeUInt32NoTag(26);
      output.writeUInt32NoTag(locationIndicesMemoizedSerializedSize);
    }
    for (int i = 0; i < locationIndices_.size(); i++) {
      output.writeInt32NoTag(locationIndices_.getInt(i));
    }
    if (timeNanos_ != 0L) {
      output.writeInt64(4, timeNanos_);
    }
    if (durationNanos_ != 0L) {
      output.writeInt64(5, durationNanos_);
    }
    if (periodType_ != null) {
      output.writeMessage(6, getPeriodType());
    }
    if (period_ != 0L) {
      output.writeInt64(7, period_);
    }
    if (getCommentStrindicesList().size() > 0) {
      output.writeUInt32NoTag(66);
      output.writeUInt32NoTag(commentStrindicesMemoizedSerializedSize);
    }
    for (int i = 0; i < commentStrindices_.size(); i++) {
      output.writeInt32NoTag(commentStrindices_.getInt(i));
    }
    if (defaultSampleTypeIndex_ != 0) {
      output.writeInt32(9, defaultSampleTypeIndex_);
    }
    if (!profileId_.isEmpty()) {
      output.writeBytes(10, profileId_);
    }
    if (droppedAttributesCount_ != 0) {
      output.writeUInt32(11, droppedAttributesCount_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(originalPayloadFormat_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 12, originalPayloadFormat_);
    }
    if (!originalPayload_.isEmpty()) {
      output.writeBytes(13, originalPayload_);
    }
    if (getAttributeIndicesList().size() > 0) {
      output.writeUInt32NoTag(114);
      output.writeUInt32NoTag(attributeIndicesMemoizedSerializedSize);
    }
    for (int i = 0; i < attributeIndices_.size(); i++) {
      output.writeInt32NoTag(attributeIndices_.getInt(i));
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    for (int i = 0; i < sampleType_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(1, sampleType_.get(i));
    }
    for (int i = 0; i < sample_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(2, sample_.get(i));
    }
    {
      int dataSize = 0;
      for (int i = 0; i < locationIndices_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeInt32SizeNoTag(locationIndices_.getInt(i));
      }
      size += dataSize;
      if (!getLocationIndicesList().isEmpty()) {
        size += 1;
        size += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(dataSize);
      }
      locationIndicesMemoizedSerializedSize = dataSize;
    }
    if (timeNanos_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(4, timeNanos_);
    }
    if (durationNanos_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(5, durationNanos_);
    }
    if (periodType_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getPeriodType());
    }
    if (period_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(7, period_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < commentStrindices_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeInt32SizeNoTag(commentStrindices_.getInt(i));
      }
      size += dataSize;
      if (!getCommentStrindicesList().isEmpty()) {
        size += 1;
        size += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(dataSize);
      }
      commentStrindicesMemoizedSerializedSize = dataSize;
    }
    if (defaultSampleTypeIndex_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(9, defaultSampleTypeIndex_);
    }
    if (!profileId_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeBytesSize(10, profileId_);
    }
    if (droppedAttributesCount_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(11, droppedAttributesCount_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(originalPayloadFormat_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, originalPayloadFormat_);
    }
    if (!originalPayload_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeBytesSize(13, originalPayload_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < attributeIndices_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeInt32SizeNoTag(attributeIndices_.getInt(i));
      }
      size += dataSize;
      if (!getAttributeIndicesList().isEmpty()) {
        size += 1;
        size += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(dataSize);
      }
      attributeIndicesMemoizedSerializedSize = dataSize;
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.opentelemetry.proto.profiles.v1development.Profile)) {
      return super.equals(obj);
    }
    io.opentelemetry.proto.profiles.v1development.Profile other = (io.opentelemetry.proto.profiles.v1development.Profile) obj;

    if (!getSampleTypeList()
        .equals(other.getSampleTypeList())) return false;
    if (!getSampleList()
        .equals(other.getSampleList())) return false;
    if (!getLocationIndicesList()
        .equals(other.getLocationIndicesList())) return false;
    if (getTimeNanos()
        != other.getTimeNanos()) return false;
    if (getDurationNanos()
        != other.getDurationNanos()) return false;
    if (hasPeriodType() != other.hasPeriodType()) return false;
    if (hasPeriodType()) {
      if (!getPeriodType()
          .equals(other.getPeriodType())) return false;
    }
    if (getPeriod()
        != other.getPeriod()) return false;
    if (!getCommentStrindicesList()
        .equals(other.getCommentStrindicesList())) return false;
    if (getDefaultSampleTypeIndex()
        != other.getDefaultSampleTypeIndex()) return false;
    if (!getProfileId()
        .equals(other.getProfileId())) return false;
    if (getDroppedAttributesCount()
        != other.getDroppedAttributesCount()) return false;
    if (!getOriginalPayloadFormat()
        .equals(other.getOriginalPayloadFormat())) return false;
    if (!getOriginalPayload()
        .equals(other.getOriginalPayload())) return false;
    if (!getAttributeIndicesList()
        .equals(other.getAttributeIndicesList())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (getSampleTypeCount() > 0) {
      hash = (37 * hash) + SAMPLE_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getSampleTypeList().hashCode();
    }
    if (getSampleCount() > 0) {
      hash = (37 * hash) + SAMPLE_FIELD_NUMBER;
      hash = (53 * hash) + getSampleList().hashCode();
    }
    if (getLocationIndicesCount() > 0) {
      hash = (37 * hash) + LOCATION_INDICES_FIELD_NUMBER;
      hash = (53 * hash) + getLocationIndicesList().hashCode();
    }
    hash = (37 * hash) + TIME_NANOS_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getTimeNanos());
    hash = (37 * hash) + DURATION_NANOS_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getDurationNanos());
    if (hasPeriodType()) {
      hash = (37 * hash) + PERIOD_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getPeriodType().hashCode();
    }
    hash = (37 * hash) + PERIOD_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
        getPeriod());
    if (getCommentStrindicesCount() > 0) {
      hash = (37 * hash) + COMMENT_STRINDICES_FIELD_NUMBER;
      hash = (53 * hash) + getCommentStrindicesList().hashCode();
    }
    hash = (37 * hash) + DEFAULT_SAMPLE_TYPE_INDEX_FIELD_NUMBER;
    hash = (53 * hash) + getDefaultSampleTypeIndex();
    hash = (37 * hash) + PROFILE_ID_FIELD_NUMBER;
    hash = (53 * hash) + getProfileId().hashCode();
    hash = (37 * hash) + DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER;
    hash = (53 * hash) + getDroppedAttributesCount();
    hash = (37 * hash) + ORIGINAL_PAYLOAD_FORMAT_FIELD_NUMBER;
    hash = (53 * hash) + getOriginalPayloadFormat().hashCode();
    hash = (37 * hash) + ORIGINAL_PAYLOAD_FIELD_NUMBER;
    hash = (53 * hash) + getOriginalPayload().hashCode();
    if (getAttributeIndicesCount() > 0) {
      hash = (37 * hash) + ATTRIBUTE_INDICES_FIELD_NUMBER;
      hash = (53 * hash) + getAttributeIndicesList().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.opentelemetry.proto.profiles.v1development.Profile parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.opentelemetry.proto.profiles.v1development.Profile prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Represents a complete profile, including sample types, samples,
   * mappings to binaries, locations, functions, string table, and additional metadata.
   * It modifies and annotates pprof Profile with OpenTelemetry specific fields.
   * Note that whilst fields in this message retain the name and field id from pprof in most cases
   * for ease of understanding data migration, it is not intended that pprof:Profile and
   * OpenTelemetry:Profile encoding be wire compatible.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.profiles.v1development.Profile}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:opentelemetry.proto.profiles.v1development.Profile)
      io.opentelemetry.proto.profiles.v1development.ProfileOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.opentelemetry.proto.profiles.v1development.ProfilesProto.internal_static_opentelemetry_proto_profiles_v1development_Profile_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.opentelemetry.proto.profiles.v1development.ProfilesProto.internal_static_opentelemetry_proto_profiles_v1development_Profile_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.opentelemetry.proto.profiles.v1development.Profile.class, io.opentelemetry.proto.profiles.v1development.Profile.Builder.class);
    }

    // Construct using io.opentelemetry.proto.profiles.v1development.Profile.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getSampleTypeFieldBuilder();
        getSampleFieldBuilder();
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      if (sampleTypeBuilder_ == null) {
        sampleType_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
      } else {
        sampleTypeBuilder_.clear();
      }
      if (sampleBuilder_ == null) {
        sample_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
      } else {
        sampleBuilder_.clear();
      }
      locationIndices_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000004);
      timeNanos_ = 0L;

      durationNanos_ = 0L;

      if (periodTypeBuilder_ == null) {
        periodType_ = null;
      } else {
        periodType_ = null;
        periodTypeBuilder_ = null;
      }
      period_ = 0L;

      commentStrindices_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000008);
      defaultSampleTypeIndex_ = 0;

      profileId_ = com.google.protobuf.ByteString.EMPTY;

      droppedAttributesCount_ = 0;

      originalPayloadFormat_ = "";

      originalPayload_ = com.google.protobuf.ByteString.EMPTY;

      attributeIndices_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000010);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.opentelemetry.proto.profiles.v1development.ProfilesProto.internal_static_opentelemetry_proto_profiles_v1development_Profile_descriptor;
    }

    @java.lang.Override
    public io.opentelemetry.proto.profiles.v1development.Profile getDefaultInstanceForType() {
      return io.opentelemetry.proto.profiles.v1development.Profile.getDefaultInstance();
    }

    @java.lang.Override
    public io.opentelemetry.proto.profiles.v1development.Profile build() {
      io.opentelemetry.proto.profiles.v1development.Profile result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.opentelemetry.proto.profiles.v1development.Profile buildPartial() {
      io.opentelemetry.proto.profiles.v1development.Profile result = new io.opentelemetry.proto.profiles.v1development.Profile(this);
      int from_bitField0_ = bitField0_;
      if (sampleTypeBuilder_ == null) {
        if (((bitField0_ & 0x00000001) != 0)) {
          sampleType_ = java.util.Collections.unmodifiableList(sampleType_);
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.sampleType_ = sampleType_;
      } else {
        result.sampleType_ = sampleTypeBuilder_.build();
      }
      if (sampleBuilder_ == null) {
        if (((bitField0_ & 0x00000002) != 0)) {
          sample_ = java.util.Collections.unmodifiableList(sample_);
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.sample_ = sample_;
      } else {
        result.sample_ = sampleBuilder_.build();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        locationIndices_.makeImmutable();
        bitField0_ = (bitField0_ & ~0x00000004);
      }
      result.locationIndices_ = locationIndices_;
      result.timeNanos_ = timeNanos_;
      result.durationNanos_ = durationNanos_;
      if (periodTypeBuilder_ == null) {
        result.periodType_ = periodType_;
      } else {
        result.periodType_ = periodTypeBuilder_.build();
      }
      result.period_ = period_;
      if (((bitField0_ & 0x00000008) != 0)) {
        commentStrindices_.makeImmutable();
        bitField0_ = (bitField0_ & ~0x00000008);
      }
      result.commentStrindices_ = commentStrindices_;
      result.defaultSampleTypeIndex_ = defaultSampleTypeIndex_;
      result.profileId_ = profileId_;
      result.droppedAttributesCount_ = droppedAttributesCount_;
      result.originalPayloadFormat_ = originalPayloadFormat_;
      result.originalPayload_ = originalPayload_;
      if (((bitField0_ & 0x00000010) != 0)) {
        attributeIndices_.makeImmutable();
        bitField0_ = (bitField0_ & ~0x00000010);
      }
      result.attributeIndices_ = attributeIndices_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.opentelemetry.proto.profiles.v1development.Profile) {
        return mergeFrom((io.opentelemetry.proto.profiles.v1development.Profile)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.opentelemetry.proto.profiles.v1development.Profile other) {
      if (other == io.opentelemetry.proto.profiles.v1development.Profile.getDefaultInstance()) return this;
      if (sampleTypeBuilder_ == null) {
        if (!other.sampleType_.isEmpty()) {
          if (sampleType_.isEmpty()) {
            sampleType_ = other.sampleType_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureSampleTypeIsMutable();
            sampleType_.addAll(other.sampleType_);
          }
          onChanged();
        }
      } else {
        if (!other.sampleType_.isEmpty()) {
          if (sampleTypeBuilder_.isEmpty()) {
            sampleTypeBuilder_.dispose();
            sampleTypeBuilder_ = null;
            sampleType_ = other.sampleType_;
            bitField0_ = (bitField0_ & ~0x00000001);
            sampleTypeBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getSampleTypeFieldBuilder() : null;
          } else {
            sampleTypeBuilder_.addAllMessages(other.sampleType_);
          }
        }
      }
      if (sampleBuilder_ == null) {
        if (!other.sample_.isEmpty()) {
          if (sample_.isEmpty()) {
            sample_ = other.sample_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureSampleIsMutable();
            sample_.addAll(other.sample_);
          }
          onChanged();
        }
      } else {
        if (!other.sample_.isEmpty()) {
          if (sampleBuilder_.isEmpty()) {
            sampleBuilder_.dispose();
            sampleBuilder_ = null;
            sample_ = other.sample_;
            bitField0_ = (bitField0_ & ~0x00000002);
            sampleBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getSampleFieldBuilder() : null;
          } else {
            sampleBuilder_.addAllMessages(other.sample_);
          }
        }
      }
      if (!other.locationIndices_.isEmpty()) {
        if (locationIndices_.isEmpty()) {
          locationIndices_ = other.locationIndices_;
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          ensureLocationIndicesIsMutable();
          locationIndices_.addAll(other.locationIndices_);
        }
        onChanged();
      }
      if (other.getTimeNanos() != 0L) {
        setTimeNanos(other.getTimeNanos());
      }
      if (other.getDurationNanos() != 0L) {
        setDurationNanos(other.getDurationNanos());
      }
      if (other.hasPeriodType()) {
        mergePeriodType(other.getPeriodType());
      }
      if (other.getPeriod() != 0L) {
        setPeriod(other.getPeriod());
      }
      if (!other.commentStrindices_.isEmpty()) {
        if (commentStrindices_.isEmpty()) {
          commentStrindices_ = other.commentStrindices_;
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          ensureCommentStrindicesIsMutable();
          commentStrindices_.addAll(other.commentStrindices_);
        }
        onChanged();
      }
      if (other.getDefaultSampleTypeIndex() != 0) {
        setDefaultSampleTypeIndex(other.getDefaultSampleTypeIndex());
      }
      if (other.getProfileId() != com.google.protobuf.ByteString.EMPTY) {
        setProfileId(other.getProfileId());
      }
      if (other.getDroppedAttributesCount() != 0) {
        setDroppedAttributesCount(other.getDroppedAttributesCount());
      }
      if (!other.getOriginalPayloadFormat().isEmpty()) {
        originalPayloadFormat_ = other.originalPayloadFormat_;
        onChanged();
      }
      if (other.getOriginalPayload() != com.google.protobuf.ByteString.EMPTY) {
        setOriginalPayload(other.getOriginalPayload());
      }
      if (!other.attributeIndices_.isEmpty()) {
        if (attributeIndices_.isEmpty()) {
          attributeIndices_ = other.attributeIndices_;
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          ensureAttributeIndicesIsMutable();
          attributeIndices_.addAll(other.attributeIndices_);
        }
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.opentelemetry.proto.profiles.v1development.Profile parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.opentelemetry.proto.profiles.v1development.Profile) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private java.util.List<io.opentelemetry.proto.profiles.v1development.ValueType> sampleType_ =
      java.util.Collections.emptyList();
    private void ensureSampleTypeIsMutable() {
      if (!((bitField0_ & 0x00000001) != 0)) {
        sampleType_ = new java.util.ArrayList<io.opentelemetry.proto.profiles.v1development.ValueType>(sampleType_);
        bitField0_ |= 0x00000001;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.opentelemetry.proto.profiles.v1development.ValueType, io.opentelemetry.proto.profiles.v1development.ValueType.Builder, io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder> sampleTypeBuilder_;

    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public java.util.List<io.opentelemetry.proto.profiles.v1development.ValueType> getSampleTypeList() {
      if (sampleTypeBuilder_ == null) {
        return java.util.Collections.unmodifiableList(sampleType_);
      } else {
        return sampleTypeBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public int getSampleTypeCount() {
      if (sampleTypeBuilder_ == null) {
        return sampleType_.size();
      } else {
        return sampleTypeBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.ValueType getSampleType(int index) {
      if (sampleTypeBuilder_ == null) {
        return sampleType_.get(index);
      } else {
        return sampleTypeBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder setSampleType(
        int index, io.opentelemetry.proto.profiles.v1development.ValueType value) {
      if (sampleTypeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSampleTypeIsMutable();
        sampleType_.set(index, value);
        onChanged();
      } else {
        sampleTypeBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder setSampleType(
        int index, io.opentelemetry.proto.profiles.v1development.ValueType.Builder builderForValue) {
      if (sampleTypeBuilder_ == null) {
        ensureSampleTypeIsMutable();
        sampleType_.set(index, builderForValue.build());
        onChanged();
      } else {
        sampleTypeBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder addSampleType(io.opentelemetry.proto.profiles.v1development.ValueType value) {
      if (sampleTypeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSampleTypeIsMutable();
        sampleType_.add(value);
        onChanged();
      } else {
        sampleTypeBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder addSampleType(
        int index, io.opentelemetry.proto.profiles.v1development.ValueType value) {
      if (sampleTypeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSampleTypeIsMutable();
        sampleType_.add(index, value);
        onChanged();
      } else {
        sampleTypeBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder addSampleType(
        io.opentelemetry.proto.profiles.v1development.ValueType.Builder builderForValue) {
      if (sampleTypeBuilder_ == null) {
        ensureSampleTypeIsMutable();
        sampleType_.add(builderForValue.build());
        onChanged();
      } else {
        sampleTypeBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder addSampleType(
        int index, io.opentelemetry.proto.profiles.v1development.ValueType.Builder builderForValue) {
      if (sampleTypeBuilder_ == null) {
        ensureSampleTypeIsMutable();
        sampleType_.add(index, builderForValue.build());
        onChanged();
      } else {
        sampleTypeBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder addAllSampleType(
        java.lang.Iterable<? extends io.opentelemetry.proto.profiles.v1development.ValueType> values) {
      if (sampleTypeBuilder_ == null) {
        ensureSampleTypeIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, sampleType_);
        onChanged();
      } else {
        sampleTypeBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder clearSampleType() {
      if (sampleTypeBuilder_ == null) {
        sampleType_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
      } else {
        sampleTypeBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public Builder removeSampleType(int index) {
      if (sampleTypeBuilder_ == null) {
        ensureSampleTypeIsMutable();
        sampleType_.remove(index);
        onChanged();
      } else {
        sampleTypeBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.ValueType.Builder getSampleTypeBuilder(
        int index) {
      return getSampleTypeFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder getSampleTypeOrBuilder(
        int index) {
      if (sampleTypeBuilder_ == null) {
        return sampleType_.get(index);  } else {
        return sampleTypeBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public java.util.List<? extends io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder> 
         getSampleTypeOrBuilderList() {
      if (sampleTypeBuilder_ != null) {
        return sampleTypeBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(sampleType_);
      }
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.ValueType.Builder addSampleTypeBuilder() {
      return getSampleTypeFieldBuilder().addBuilder(
          io.opentelemetry.proto.profiles.v1development.ValueType.getDefaultInstance());
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.ValueType.Builder addSampleTypeBuilder(
        int index) {
      return getSampleTypeFieldBuilder().addBuilder(
          index, io.opentelemetry.proto.profiles.v1development.ValueType.getDefaultInstance());
    }
    /**
     * <pre>
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;</code>
     */
    public java.util.List<io.opentelemetry.proto.profiles.v1development.ValueType.Builder> 
         getSampleTypeBuilderList() {
      return getSampleTypeFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.opentelemetry.proto.profiles.v1development.ValueType, io.opentelemetry.proto.profiles.v1development.ValueType.Builder, io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder> 
        getSampleTypeFieldBuilder() {
      if (sampleTypeBuilder_ == null) {
        sampleTypeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.opentelemetry.proto.profiles.v1development.ValueType, io.opentelemetry.proto.profiles.v1development.ValueType.Builder, io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder>(
                sampleType_,
                ((bitField0_ & 0x00000001) != 0),
                getParentForChildren(),
                isClean());
        sampleType_ = null;
      }
      return sampleTypeBuilder_;
    }

    private java.util.List<io.opentelemetry.proto.profiles.v1development.Sample> sample_ =
      java.util.Collections.emptyList();
    private void ensureSampleIsMutable() {
      if (!((bitField0_ & 0x00000002) != 0)) {
        sample_ = new java.util.ArrayList<io.opentelemetry.proto.profiles.v1development.Sample>(sample_);
        bitField0_ |= 0x00000002;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.opentelemetry.proto.profiles.v1development.Sample, io.opentelemetry.proto.profiles.v1development.Sample.Builder, io.opentelemetry.proto.profiles.v1development.SampleOrBuilder> sampleBuilder_;

    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public java.util.List<io.opentelemetry.proto.profiles.v1development.Sample> getSampleList() {
      if (sampleBuilder_ == null) {
        return java.util.Collections.unmodifiableList(sample_);
      } else {
        return sampleBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public int getSampleCount() {
      if (sampleBuilder_ == null) {
        return sample_.size();
      } else {
        return sampleBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.Sample getSample(int index) {
      if (sampleBuilder_ == null) {
        return sample_.get(index);
      } else {
        return sampleBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder setSample(
        int index, io.opentelemetry.proto.profiles.v1development.Sample value) {
      if (sampleBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSampleIsMutable();
        sample_.set(index, value);
        onChanged();
      } else {
        sampleBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder setSample(
        int index, io.opentelemetry.proto.profiles.v1development.Sample.Builder builderForValue) {
      if (sampleBuilder_ == null) {
        ensureSampleIsMutable();
        sample_.set(index, builderForValue.build());
        onChanged();
      } else {
        sampleBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder addSample(io.opentelemetry.proto.profiles.v1development.Sample value) {
      if (sampleBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSampleIsMutable();
        sample_.add(value);
        onChanged();
      } else {
        sampleBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder addSample(
        int index, io.opentelemetry.proto.profiles.v1development.Sample value) {
      if (sampleBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSampleIsMutable();
        sample_.add(index, value);
        onChanged();
      } else {
        sampleBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder addSample(
        io.opentelemetry.proto.profiles.v1development.Sample.Builder builderForValue) {
      if (sampleBuilder_ == null) {
        ensureSampleIsMutable();
        sample_.add(builderForValue.build());
        onChanged();
      } else {
        sampleBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder addSample(
        int index, io.opentelemetry.proto.profiles.v1development.Sample.Builder builderForValue) {
      if (sampleBuilder_ == null) {
        ensureSampleIsMutable();
        sample_.add(index, builderForValue.build());
        onChanged();
      } else {
        sampleBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder addAllSample(
        java.lang.Iterable<? extends io.opentelemetry.proto.profiles.v1development.Sample> values) {
      if (sampleBuilder_ == null) {
        ensureSampleIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, sample_);
        onChanged();
      } else {
        sampleBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder clearSample() {
      if (sampleBuilder_ == null) {
        sample_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
      } else {
        sampleBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public Builder removeSample(int index) {
      if (sampleBuilder_ == null) {
        ensureSampleIsMutable();
        sample_.remove(index);
        onChanged();
      } else {
        sampleBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.Sample.Builder getSampleBuilder(
        int index) {
      return getSampleFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.SampleOrBuilder getSampleOrBuilder(
        int index) {
      if (sampleBuilder_ == null) {
        return sample_.get(index);  } else {
        return sampleBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public java.util.List<? extends io.opentelemetry.proto.profiles.v1development.SampleOrBuilder> 
         getSampleOrBuilderList() {
      if (sampleBuilder_ != null) {
        return sampleBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(sample_);
      }
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.Sample.Builder addSampleBuilder() {
      return getSampleFieldBuilder().addBuilder(
          io.opentelemetry.proto.profiles.v1development.Sample.getDefaultInstance());
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.Sample.Builder addSampleBuilder(
        int index) {
      return getSampleFieldBuilder().addBuilder(
          index, io.opentelemetry.proto.profiles.v1development.Sample.getDefaultInstance());
    }
    /**
     * <pre>
     * The set of samples recorded in this profile.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.profiles.v1development.Sample sample = 2;</code>
     */
    public java.util.List<io.opentelemetry.proto.profiles.v1development.Sample.Builder> 
         getSampleBuilderList() {
      return getSampleFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.opentelemetry.proto.profiles.v1development.Sample, io.opentelemetry.proto.profiles.v1development.Sample.Builder, io.opentelemetry.proto.profiles.v1development.SampleOrBuilder> 
        getSampleFieldBuilder() {
      if (sampleBuilder_ == null) {
        sampleBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.opentelemetry.proto.profiles.v1development.Sample, io.opentelemetry.proto.profiles.v1development.Sample.Builder, io.opentelemetry.proto.profiles.v1development.SampleOrBuilder>(
                sample_,
                ((bitField0_ & 0x00000002) != 0),
                getParentForChildren(),
                isClean());
        sample_ = null;
      }
      return sampleBuilder_;
    }

    private com.google.protobuf.Internal.IntList locationIndices_ = emptyIntList();
    private void ensureLocationIndicesIsMutable() {
      if (!((bitField0_ & 0x00000004) != 0)) {
        locationIndices_ = mutableCopy(locationIndices_);
        bitField0_ |= 0x00000004;
       }
    }
    /**
     * <pre>
     * References to locations in ProfilesDictionary.location_table.
     * </pre>
     *
     * <code>repeated int32 location_indices = 3;</code>
     * @return A list containing the locationIndices.
     */
    public java.util.List<java.lang.Integer>
        getLocationIndicesList() {
      return ((bitField0_ & 0x00000004) != 0) ?
               java.util.Collections.unmodifiableList(locationIndices_) : locationIndices_;
    }
    /**
     * <pre>
     * References to locations in ProfilesDictionary.location_table.
     * </pre>
     *
     * <code>repeated int32 location_indices = 3;</code>
     * @return The count of locationIndices.
     */
    public int getLocationIndicesCount() {
      return locationIndices_.size();
    }
    /**
     * <pre>
     * References to locations in ProfilesDictionary.location_table.
     * </pre>
     *
     * <code>repeated int32 location_indices = 3;</code>
     * @param index The index of the element to return.
     * @return The locationIndices at the given index.
     */
    public int getLocationIndices(int index) {
      return locationIndices_.getInt(index);
    }
    /**
     * <pre>
     * References to locations in ProfilesDictionary.location_table.
     * </pre>
     *
     * <code>repeated int32 location_indices = 3;</code>
     * @param index The index to set the value at.
     * @param value The locationIndices to set.
     * @return This builder for chaining.
     */
    public Builder setLocationIndices(
        int index, int value) {
      ensureLocationIndicesIsMutable();
      locationIndices_.setInt(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * References to locations in ProfilesDictionary.location_table.
     * </pre>
     *
     * <code>repeated int32 location_indices = 3;</code>
     * @param value The locationIndices to add.
     * @return This builder for chaining.
     */
    public Builder addLocationIndices(int value) {
      ensureLocationIndicesIsMutable();
      locationIndices_.addInt(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * References to locations in ProfilesDictionary.location_table.
     * </pre>
     *
     * <code>repeated int32 location_indices = 3;</code>
     * @param values The locationIndices to add.
     * @return This builder for chaining.
     */
    public Builder addAllLocationIndices(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureLocationIndicesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, locationIndices_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * References to locations in ProfilesDictionary.location_table.
     * </pre>
     *
     * <code>repeated int32 location_indices = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearLocationIndices() {
      locationIndices_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }

    private long timeNanos_ ;
    /**
     * <pre>
     * Time of collection (UTC) represented as nanoseconds past the epoch.
     * </pre>
     *
     * <code>int64 time_nanos = 4;</code>
     * @return The timeNanos.
     */
    @java.lang.Override
    public long getTimeNanos() {
      return timeNanos_;
    }
    /**
     * <pre>
     * Time of collection (UTC) represented as nanoseconds past the epoch.
     * </pre>
     *
     * <code>int64 time_nanos = 4;</code>
     * @param value The timeNanos to set.
     * @return This builder for chaining.
     */
    public Builder setTimeNanos(long value) {
      
      timeNanos_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Time of collection (UTC) represented as nanoseconds past the epoch.
     * </pre>
     *
     * <code>int64 time_nanos = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearTimeNanos() {
      
      timeNanos_ = 0L;
      onChanged();
      return this;
    }

    private long durationNanos_ ;
    /**
     * <pre>
     * Duration of the profile, if a duration makes sense.
     * </pre>
     *
     * <code>int64 duration_nanos = 5;</code>
     * @return The durationNanos.
     */
    @java.lang.Override
    public long getDurationNanos() {
      return durationNanos_;
    }
    /**
     * <pre>
     * Duration of the profile, if a duration makes sense.
     * </pre>
     *
     * <code>int64 duration_nanos = 5;</code>
     * @param value The durationNanos to set.
     * @return This builder for chaining.
     */
    public Builder setDurationNanos(long value) {
      
      durationNanos_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Duration of the profile, if a duration makes sense.
     * </pre>
     *
     * <code>int64 duration_nanos = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearDurationNanos() {
      
      durationNanos_ = 0L;
      onChanged();
      return this;
    }

    private io.opentelemetry.proto.profiles.v1development.ValueType periodType_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.opentelemetry.proto.profiles.v1development.ValueType, io.opentelemetry.proto.profiles.v1development.ValueType.Builder, io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder> periodTypeBuilder_;
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     * @return Whether the periodType field is set.
     */
    public boolean hasPeriodType() {
      return periodTypeBuilder_ != null || periodType_ != null;
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     * @return The periodType.
     */
    public io.opentelemetry.proto.profiles.v1development.ValueType getPeriodType() {
      if (periodTypeBuilder_ == null) {
        return periodType_ == null ? io.opentelemetry.proto.profiles.v1development.ValueType.getDefaultInstance() : periodType_;
      } else {
        return periodTypeBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     */
    public Builder setPeriodType(io.opentelemetry.proto.profiles.v1development.ValueType value) {
      if (periodTypeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        periodType_ = value;
        onChanged();
      } else {
        periodTypeBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     */
    public Builder setPeriodType(
        io.opentelemetry.proto.profiles.v1development.ValueType.Builder builderForValue) {
      if (periodTypeBuilder_ == null) {
        periodType_ = builderForValue.build();
        onChanged();
      } else {
        periodTypeBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     */
    public Builder mergePeriodType(io.opentelemetry.proto.profiles.v1development.ValueType value) {
      if (periodTypeBuilder_ == null) {
        if (periodType_ != null) {
          periodType_ =
            io.opentelemetry.proto.profiles.v1development.ValueType.newBuilder(periodType_).mergeFrom(value).buildPartial();
        } else {
          periodType_ = value;
        }
        onChanged();
      } else {
        periodTypeBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     */
    public Builder clearPeriodType() {
      if (periodTypeBuilder_ == null) {
        periodType_ = null;
        onChanged();
      } else {
        periodType_ = null;
        periodTypeBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.ValueType.Builder getPeriodTypeBuilder() {
      
      onChanged();
      return getPeriodTypeFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     */
    public io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder getPeriodTypeOrBuilder() {
      if (periodTypeBuilder_ != null) {
        return periodTypeBuilder_.getMessageOrBuilder();
      } else {
        return periodType_ == null ?
            io.opentelemetry.proto.profiles.v1development.ValueType.getDefaultInstance() : periodType_;
      }
    }
    /**
     * <pre>
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     * </pre>
     *
     * <code>.opentelemetry.proto.profiles.v1development.ValueType period_type = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.opentelemetry.proto.profiles.v1development.ValueType, io.opentelemetry.proto.profiles.v1development.ValueType.Builder, io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder> 
        getPeriodTypeFieldBuilder() {
      if (periodTypeBuilder_ == null) {
        periodTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.opentelemetry.proto.profiles.v1development.ValueType, io.opentelemetry.proto.profiles.v1development.ValueType.Builder, io.opentelemetry.proto.profiles.v1development.ValueTypeOrBuilder>(
                getPeriodType(),
                getParentForChildren(),
                isClean());
        periodType_ = null;
      }
      return periodTypeBuilder_;
    }

    private long period_ ;
    /**
     * <pre>
     * The number of events between sampled occurrences.
     * </pre>
     *
     * <code>int64 period = 7;</code>
     * @return The period.
     */
    @java.lang.Override
    public long getPeriod() {
      return period_;
    }
    /**
     * <pre>
     * The number of events between sampled occurrences.
     * </pre>
     *
     * <code>int64 period = 7;</code>
     * @param value The period to set.
     * @return This builder for chaining.
     */
    public Builder setPeriod(long value) {
      
      period_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of events between sampled occurrences.
     * </pre>
     *
     * <code>int64 period = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearPeriod() {
      
      period_ = 0L;
      onChanged();
      return this;
    }

    private com.google.protobuf.Internal.IntList commentStrindices_ = emptyIntList();
    private void ensureCommentStrindicesIsMutable() {
      if (!((bitField0_ & 0x00000008) != 0)) {
        commentStrindices_ = mutableCopy(commentStrindices_);
        bitField0_ |= 0x00000008;
       }
    }
    /**
     * <pre>
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     * </pre>
     *
     * <code>repeated int32 comment_strindices = 8;</code>
     * @return A list containing the commentStrindices.
     */
    public java.util.List<java.lang.Integer>
        getCommentStrindicesList() {
      return ((bitField0_ & 0x00000008) != 0) ?
               java.util.Collections.unmodifiableList(commentStrindices_) : commentStrindices_;
    }
    /**
     * <pre>
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     * </pre>
     *
     * <code>repeated int32 comment_strindices = 8;</code>
     * @return The count of commentStrindices.
     */
    public int getCommentStrindicesCount() {
      return commentStrindices_.size();
    }
    /**
     * <pre>
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     * </pre>
     *
     * <code>repeated int32 comment_strindices = 8;</code>
     * @param index The index of the element to return.
     * @return The commentStrindices at the given index.
     */
    public int getCommentStrindices(int index) {
      return commentStrindices_.getInt(index);
    }
    /**
     * <pre>
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     * </pre>
     *
     * <code>repeated int32 comment_strindices = 8;</code>
     * @param index The index to set the value at.
     * @param value The commentStrindices to set.
     * @return This builder for chaining.
     */
    public Builder setCommentStrindices(
        int index, int value) {
      ensureCommentStrindicesIsMutable();
      commentStrindices_.setInt(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     * </pre>
     *
     * <code>repeated int32 comment_strindices = 8;</code>
     * @param value The commentStrindices to add.
     * @return This builder for chaining.
     */
    public Builder addCommentStrindices(int value) {
      ensureCommentStrindicesIsMutable();
      commentStrindices_.addInt(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     * </pre>
     *
     * <code>repeated int32 comment_strindices = 8;</code>
     * @param values The commentStrindices to add.
     * @return This builder for chaining.
     */
    public Builder addAllCommentStrindices(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureCommentStrindicesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, commentStrindices_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     * </pre>
     *
     * <code>repeated int32 comment_strindices = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearCommentStrindices() {
      commentStrindices_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000008);
      onChanged();
      return this;
    }

    private int defaultSampleTypeIndex_ ;
    /**
     * <pre>
     * Index into the sample_type array to the default sample type.
     * </pre>
     *
     * <code>int32 default_sample_type_index = 9;</code>
     * @return The defaultSampleTypeIndex.
     */
    @java.lang.Override
    public int getDefaultSampleTypeIndex() {
      return defaultSampleTypeIndex_;
    }
    /**
     * <pre>
     * Index into the sample_type array to the default sample type.
     * </pre>
     *
     * <code>int32 default_sample_type_index = 9;</code>
     * @param value The defaultSampleTypeIndex to set.
     * @return This builder for chaining.
     */
    public Builder setDefaultSampleTypeIndex(int value) {
      
      defaultSampleTypeIndex_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Index into the sample_type array to the default sample type.
     * </pre>
     *
     * <code>int32 default_sample_type_index = 9;</code>
     * @return This builder for chaining.
     */
    public Builder clearDefaultSampleTypeIndex() {
      
      defaultSampleTypeIndex_ = 0;
      onChanged();
      return this;
    }

    private com.google.protobuf.ByteString profileId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
     * all zeroes is considered invalid.
     * This field is required.
     * </pre>
     *
     * <code>bytes profile_id = 10;</code>
     * @return The profileId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getProfileId() {
      return profileId_;
    }
    /**
     * <pre>
     * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
     * all zeroes is considered invalid.
     * This field is required.
     * </pre>
     *
     * <code>bytes profile_id = 10;</code>
     * @param value The profileId to set.
     * @return This builder for chaining.
     */
    public Builder setProfileId(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      profileId_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
     * all zeroes is considered invalid.
     * This field is required.
     * </pre>
     *
     * <code>bytes profile_id = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearProfileId() {
      
      profileId_ = getDefaultInstance().getProfileId();
      onChanged();
      return this;
    }

    private int droppedAttributesCount_ ;
    /**
     * <pre>
     * dropped_attributes_count is the number of attributes that were discarded. Attributes
     * can be discarded because their keys are too long or because there are too many
     * attributes. If this value is 0, then no attributes were dropped.
     * </pre>
     *
     * <code>uint32 dropped_attributes_count = 11;</code>
     * @return The droppedAttributesCount.
     */
    @java.lang.Override
    public int getDroppedAttributesCount() {
      return droppedAttributesCount_;
    }
    /**
     * <pre>
     * dropped_attributes_count is the number of attributes that were discarded. Attributes
     * can be discarded because their keys are too long or because there are too many
     * attributes. If this value is 0, then no attributes were dropped.
     * </pre>
     *
     * <code>uint32 dropped_attributes_count = 11;</code>
     * @param value The droppedAttributesCount to set.
     * @return This builder for chaining.
     */
    public Builder setDroppedAttributesCount(int value) {
      
      droppedAttributesCount_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * dropped_attributes_count is the number of attributes that were discarded. Attributes
     * can be discarded because their keys are too long or because there are too many
     * attributes. If this value is 0, then no attributes were dropped.
     * </pre>
     *
     * <code>uint32 dropped_attributes_count = 11;</code>
     * @return This builder for chaining.
     */
    public Builder clearDroppedAttributesCount() {
      
      droppedAttributesCount_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object originalPayloadFormat_ = "";
    /**
     * <pre>
     * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
     * </pre>
     *
     * <code>string original_payload_format = 12;</code>
     * @return The originalPayloadFormat.
     */
    public java.lang.String getOriginalPayloadFormat() {
      java.lang.Object ref = originalPayloadFormat_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        originalPayloadFormat_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
     * </pre>
     *
     * <code>string original_payload_format = 12;</code>
     * @return The bytes for originalPayloadFormat.
     */
    public com.google.protobuf.ByteString
        getOriginalPayloadFormatBytes() {
      java.lang.Object ref = originalPayloadFormat_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        originalPayloadFormat_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
     * </pre>
     *
     * <code>string original_payload_format = 12;</code>
     * @param value The originalPayloadFormat to set.
     * @return This builder for chaining.
     */
    public Builder setOriginalPayloadFormat(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      originalPayloadFormat_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
     * </pre>
     *
     * <code>string original_payload_format = 12;</code>
     * @return This builder for chaining.
     */
    public Builder clearOriginalPayloadFormat() {
      
      originalPayloadFormat_ = getDefaultInstance().getOriginalPayloadFormat();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
     * </pre>
     *
     * <code>string original_payload_format = 12;</code>
     * @param value The bytes for originalPayloadFormat to set.
     * @return This builder for chaining.
     */
    public Builder setOriginalPayloadFormatBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      originalPayloadFormat_ = value;
      onChanged();
      return this;
    }

    private com.google.protobuf.ByteString originalPayload_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Original payload can be stored in this field. This can be useful for users who want to get the original payload.
     * Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
     * Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
     * If the original payload is in pprof format, it SHOULD not be included in this field.
     * The field is optional, however if it is present then equivalent converted data should be populated in other fields
     * of this message as far as is practicable.
     * </pre>
     *
     * <code>bytes original_payload = 13;</code>
     * @return The originalPayload.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getOriginalPayload() {
      return originalPayload_;
    }
    /**
     * <pre>
     * Original payload can be stored in this field. This can be useful for users who want to get the original payload.
     * Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
     * Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
     * If the original payload is in pprof format, it SHOULD not be included in this field.
     * The field is optional, however if it is present then equivalent converted data should be populated in other fields
     * of this message as far as is practicable.
     * </pre>
     *
     * <code>bytes original_payload = 13;</code>
     * @param value The originalPayload to set.
     * @return This builder for chaining.
     */
    public Builder setOriginalPayload(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      originalPayload_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Original payload can be stored in this field. This can be useful for users who want to get the original payload.
     * Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
     * Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
     * If the original payload is in pprof format, it SHOULD not be included in this field.
     * The field is optional, however if it is present then equivalent converted data should be populated in other fields
     * of this message as far as is practicable.
     * </pre>
     *
     * <code>bytes original_payload = 13;</code>
     * @return This builder for chaining.
     */
    public Builder clearOriginalPayload() {
      
      originalPayload_ = getDefaultInstance().getOriginalPayload();
      onChanged();
      return this;
    }

    private com.google.protobuf.Internal.IntList attributeIndices_ = emptyIntList();
    private void ensureAttributeIndicesIsMutable() {
      if (!((bitField0_ & 0x00000010) != 0)) {
        attributeIndices_ = mutableCopy(attributeIndices_);
        bitField0_ |= 0x00000010;
       }
    }
    /**
     * <pre>
     * References to attributes in attribute_table. [optional]
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated int32 attribute_indices = 14;</code>
     * @return A list containing the attributeIndices.
     */
    public java.util.List<java.lang.Integer>
        getAttributeIndicesList() {
      return ((bitField0_ & 0x00000010) != 0) ?
               java.util.Collections.unmodifiableList(attributeIndices_) : attributeIndices_;
    }
    /**
     * <pre>
     * References to attributes in attribute_table. [optional]
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated int32 attribute_indices = 14;</code>
     * @return The count of attributeIndices.
     */
    public int getAttributeIndicesCount() {
      return attributeIndices_.size();
    }
    /**
     * <pre>
     * References to attributes in attribute_table. [optional]
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated int32 attribute_indices = 14;</code>
     * @param index The index of the element to return.
     * @return The attributeIndices at the given index.
     */
    public int getAttributeIndices(int index) {
      return attributeIndices_.getInt(index);
    }
    /**
     * <pre>
     * References to attributes in attribute_table. [optional]
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated int32 attribute_indices = 14;</code>
     * @param index The index to set the value at.
     * @param value The attributeIndices to set.
     * @return This builder for chaining.
     */
    public Builder setAttributeIndices(
        int index, int value) {
      ensureAttributeIndicesIsMutable();
      attributeIndices_.setInt(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * References to attributes in attribute_table. [optional]
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated int32 attribute_indices = 14;</code>
     * @param value The attributeIndices to add.
     * @return This builder for chaining.
     */
    public Builder addAttributeIndices(int value) {
      ensureAttributeIndicesIsMutable();
      attributeIndices_.addInt(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * References to attributes in attribute_table. [optional]
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated int32 attribute_indices = 14;</code>
     * @param values The attributeIndices to add.
     * @return This builder for chaining.
     */
    public Builder addAllAttributeIndices(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureAttributeIndicesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, attributeIndices_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * References to attributes in attribute_table. [optional]
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated int32 attribute_indices = 14;</code>
     * @return This builder for chaining.
     */
    public Builder clearAttributeIndices() {
      attributeIndices_ = emptyIntList();
      bitField0_ = (bitField0_ & ~0x00000010);
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:opentelemetry.proto.profiles.v1development.Profile)
  }

  // @@protoc_insertion_point(class_scope:opentelemetry.proto.profiles.v1development.Profile)
  private static final io.opentelemetry.proto.profiles.v1development.Profile DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.opentelemetry.proto.profiles.v1development.Profile();
  }

  public static io.opentelemetry.proto.profiles.v1development.Profile getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Profile>
      PARSER = new com.google.protobuf.AbstractParser<Profile>() {
    @java.lang.Override
    public Profile parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new Profile(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<Profile> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Profile> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.opentelemetry.proto.profiles.v1development.Profile getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

